#include "ukf.h"
#include "tools.h"
#include "Eigen/Dense"
#include <iostream>

using namespace std;
using Eigen::MatrixXd;
using Eigen::VectorXd;
using std::vector;

/**
 * Initializes Unscented Kalman filter
 */


UKF::UKF() {
  
  is_initialized_ = false;

  previous_timestamp_ = 0;
  
  // if this is false, laser measurements will be ignored (except during init)
  use_laser_ = true;

  // if this is false, radar measurements will be ignored (except during init)
  use_radar_ = true;

  // initial state vector
  x_ = VectorXd(dim_x);

  // Allocating state covariance matrix
  Sigma_ = MatrixXd(UKF::dim_x, UKF::dim_x);
  // These are the sigma points generated by the joint distribution 
  // of the prior and the (linear acceleration, angular accelration) distribution.
  // Thus, the dimension is dim_x_joint x (2*dim_x_joint+1)
  Xsig_joint_ = MatrixXd(dim_x_joint, 2 * dim_x_joint + 1);
  
  // These are the sigma points that yield the predicted state distribution.
  // They are obtained from the joint sigma points, so, although the rows should be x_dim, 
  // the nmumber of columns should be equal to the number of columns of Xsig_joint (i.e., 2 * dim_x_joint + 1) 
  Xsig_pred_ = MatrixXd(dim_x, 2 * dim_x_joint + 1);

  // Process noise standard deviation longitudinal acceleration in m/s^2
  std_a_ = 8;

  // Process noise standard deviation yaw acceleration in rad/s^2
  std_yawdd_ = 0.4;

  // Laser measurement noise standard deviation position1 in m
   //std_laspx_ = 0.15; // initial variance estimate
  std_laspx_ = 0.15;

  // Laser measurement noise standard deviation position2 in m
   //std_laspy_ = 0.15; // initial variance estimate
  std_laspy_  = 0.15;
  
  // Radar measurement noise standard deviation radius in m
  std_radr_ = 0.3;

  // Radar measurement noise standard deviation angle in rad
  std_radphi_ = 0.03;

  // Radar measurement noise standard deviation radius change in m/s
  std_radrd_ = 0.3;

  /**
  TODO:

  Complete the initialization. See ukf.h for other member properties.

  Hint: one or more values initialized above might be wildly off...
  */
}

UKF::~UKF() {}


// Initialization of the prior 
// either from a Lidar or a Radar measurement.
void UKF::Init(const MeasurementPackage &pack) {
	// preliminary allocation
	x_ = VectorXd(dim_x);
	
	if (pack.sensor_type_ == MeasurementPackage::LASER) { // direct initialization from the Lidar data
	  
	  //cout<<"Initial LIDAR measurement : "<<endl<<pack.raw_measurements_<<endl;
	  double px = pack.raw_measurements_[0], 
		 py = pack.raw_measurements_[1];
	  
	  if (px*px + py*py == 0) { // initialize prior with high uncertainty
	    x_ << 0.001,
		  0.001,
		  0.001,
		  0.001,
		  0.001;
	    Sigma_ = UKF::inf_variance * MatrixXd::Identity(dim_x, dim_x);
	  } 
	  else { 
	    // state mean
	    x_<< px, 
		 py,
		  0.001, 
	          0.001,
		  0.001,
		  0.001;
	
	  // state covariance
	  Sigma_ = MatrixXd::Zero(dim_x, dim_x);
	  Sigma_(0, 0) = std_laspx_ * std_laspx_;
		    Sigma_(1, 1) = std_laspy_ * std_laspy_;
			  Sigma_(2, 2) = UKF::inf_variance;
			      Sigma_(3, 3) = UKF::inf_variance;
				  Sigma_(4, 4) = UKF::inf_variance;
	  }
	  
	} else { // Oh-oh... Radar measurement...
	 
	  // obtain px, py implicitly
	  double rho = pack.raw_measurements_[0];
	  //cout<<"Initial RADAR measurement : "<<endl<<pack.raw_measurements_<<endl;
	  if (rho == 0) { // initialize the prior with high uncertainty around zero...
	    x_ <<  0, 
		   0,
		   0,
		   0;
	    Sigma_ = UKF::inf_variance * MatrixXd::Identity(dim_x, dim_x);
	  } 
	  else {
	    // NOTE: θ (theta) now is the angle of the position vector with the x-axis of the sensor
	    
	    double theta = pack.raw_measurements_[1];
	    double px = rho * cos(theta);
	    double py = rho * sin(theta);
	  
	    // get rho_dot:
	    double rho_dot = pack.raw_measurements_[2];
	    // Now, we know that, since rho_dot = (vx * px + vy * py) / norm(p):
	    // norm(v) = abs(rho_dot):
	    // So,
	    double v = fabs(rho_dot); 
	   
	    // NOTE: Now, we can extract a distribution on p and v based on the measurement,
	    //       but NOT on phi and omega. That's not too bad...
	    // So, we get sigma points from the measurement
	    const int n_y = 3;// numnber of measurements in first measuerement vector
	    double lambda = 3 - n_y;
	    
	    MatrixXd Ysigma(n_y, 2 * n_y + 1);
	    MatrixXd Qr = MatrixXd::Zero(n_y, n_y);
	    Qr(0, 0) = std_radr_ * std_radr_; 
	          Qr(1, 1) = std_radphi_ * std_radphi_;
			Qr(2, 2) = std_radrd_ * std_radrd_;
	    GenerateSigmaPoints(pack.raw_measurements_, 
				Qr,
			        Ysigma);
	    // Great! Now we need to transform the sigma points (and compute the weighhts by the way....)
	    MatrixXd Tsigma(n_y, 2 * n_y + 1); // transformed points
	    double w[2 * n_y + 1]; // weights
	    for (int i = 0; i < 2 * n_y + 1; i++) {
	      
	      w[i] = i == 0 ? lambda / (lambda + n_y) : 0.5 / (lambda + n_y);
	      double rho_t = Ysigma(0, i);
	      double theta_t = Ysigma(1, i);
	      double rho_dot_t = Ysigma(2, i);
	      double px_t = rho_t * cos(theta_t);
	      double py_t = rho_t * sin(theta_t);
	      double v_t = fabs(rho_dot_t);
	      
	      Tsigma(0, i) = px_t;
	      Tsigma(1, i) = py_t;
	      Tsigma(2, i) = v_t;
	      
	    }
	    // -Sigh-! Now compute the mean and covariance of [px, py, v]
	    VectorXd x3 = VectorXd::Zero(n_y);
	    for (int i = 0; i < 2 * n_y + 1; i++) 
	      x3 += w[i] * Tsigma.col(i);
	      
	    
	    MatrixXd Sigma3 = MatrixXd::Zero(n_y, n_y);
	    for (int i = 0; i < 2 * n_y + 1; i++) 
	      Sigma3 += w[i] * (Tsigma.col(i) - x3) * (Tsigma.col(i) - x3).transpose();
	      
	    
	    // AND FINALLY, create the prior
	    x_.segment<3>(0) = x3;
	    x_[n_y] = x_[n_y+1] = 0; // just set phi and omega to zero with lots of variance
			       // this is not too bad an assumption...
	    Sigma_ = MatrixXd::Zero(dim_x, dim_x);
	    Sigma_.block<n_y, n_y>(0, 0) = Sigma3;
	    // setting the variance of phi and omega to "infinity" because we dont anything about them just yet....
	    Sigma_(n_y, n_y) = Sigma_(n_y+1, n_y+1) = inf_variance;
	    // ALL DONE!
	    
	  
	  }
	}
	  
	// Done 
}

/**
 * @param {MeasurementPackage} meas_package The latest measurement data of
 * either radar or laser.
 */
void UKF::ProcessMeasurement(const MeasurementPackage &pack) {
   // if this is the first reception, use the measurement to initialize the prior
  if (!is_initialized_) {
	// initialize the filter
	Init(pack);
	// forward timestamp cache
	previous_timestamp_ = pack.timestamp_;
	// raise the flag so that we skip this part next time
	is_initialized_ = true; 
	return;
  }

  // Compute time since last sample
  float dt = (pack.timestamp_ - previous_timestamp_) / 1000000.0;	//dt - expressed in seconds
  // Forward sampling time 
  previous_timestamp_ = pack.timestamp_;

  while (dt > 0.2)   //<--- value is flexible
  {
      double step = 0.1;   //<--- value is flexible
      Prediction(step);
      dt -= step;
  }
  	 
  //1. Get the posterior marginal over the previous state
  Prediction(dt);

  //2. Now update the posterior
  Update(pack);
  
  // print the moments of state distribution
  cout << "x_= " << x_ << endl;
  cout << "Sigma_= " << Sigma_ << endl;


 
}

/**
 * Predicts sigma points, the state, and the state covariance matrix.
 * @param {double} delta_t the change in time (in seconds) between the last
 * measurement and this one.
 */
void UKF::Prediction(double Dt) {
  // Now generating siugma points for the JOINT distribution of 
  // x-plus the linear - angular accelerations
  GenerateJointSigmaPoints(x_, 
			   Sigma_, 
			   std_a_,
			   std_yawdd_,
			   Xsig_joint_);
  
  
  // 1. Now transforming sigma points
  const int dim_joint = Xsig_joint_.rows();
  const int n_joint_sigma_points = Xsig_joint_.cols();
  double lambda = 3 - dim_joint; // the lambda param
  
  double alpha_sq = (lambda + dim_joint) / (dim_joint + kappa);
  
  double w_m[n_joint_sigma_points ];   // mean weights
  double w_c[n_joint_sigma_points ];   // covariance weights
  
  // zeroing the predicted mean
  VectorXd x_pred = VectorXd::Zero(dim_x);
  
  //predict sigma points
  for (int i = 0; i < n_joint_sigma_points ; i++) {
	
      // btw, compute the weights here...
     if (i == 0) {
	
	w_m[i] = lambda / (lambda + dim_joint);
	w_c[i] = w_m[i] + (1 - alpha_sq + beta);
      
      } else 
	w_m[i] = w_c[i] = 0.5 / (lambda + dim_joint);
      
      // Now run sigma points through the transition/prediction equations
      double px = Xsig_joint_(0, i),
             py = Xsig_joint_(1, i),
             v = Xsig_joint_(2, i),
             // NOTE: "phi" instead of "psi"
             phi = Xsig_joint_(3, i),
             omega = Xsig_joint_(4, i),
             a = Xsig_joint_(5, i),
             omega_dot = Xsig_joint_(6, i);
	     
      // Computing the "noise", which is presumed the same in either liner or mixed-rotational motion
      double px_noise = 0.5 * Dt * Dt * cos(phi) * a,
             py_noise = 0.5 * Dt * Dt * sin(phi) * a,
             v_noise = Dt * a,
             phi_noise = 0.5 * Dt * Dt * omega_dot,
             omega_noise = Dt * omega_dot;
    
      // the following updates are common to either linear or general motion
      Xsig_pred_(2, i) = v   +                  + v_noise;
      Xsig_pred_(4, i) = omega                  + omega_noise;
      
      if (fabs(omega) < 0.001) {
      
	  Xsig_pred_(0, i) = px + v * cos(phi) * Dt + px_noise;
	  Xsig_pred_(1, i) = py + v * sin(phi) * Dt + py_noise;
	  Xsig_pred_(3, i) = phi                    + phi_noise;
    
      } else {
      
	  Xsig_pred_(0, i) = px + v * (sin(phi + omega * Dt) - sin(phi) ) / omega   + px_noise;
	  Xsig_pred_(1, i) = py + v * (-cos(phi + omega * Dt) + cos(phi) ) / omega   + py_noise;
	  Xsig_pred_(3, i) = phi + omega * Dt       				     + phi_noise;
      }
      
      x_pred += w_m[i] * Xsig_pred_.col(i);
  
  }
  
  // predicted covariance  
  MatrixXd Sigma_pred = MatrixXd::Zero(dim_x, dim_x);
  for (int i = 0; i < n_joint_sigma_points; i++)
    Sigma_pred += w_c[i] * (Xsig_pred_.col(i) - x_pred) * (Xsig_pred_.col(i) - x_pred).transpose();
  
  // assigning values
  x_ = x_pred;
  Sigma_ = Sigma_pred;
  // all done with prediction mesa thinks...

}



void UKF::Update(const MeasurementPackage& pack) {
  
  if (pack.sensor_type_ == MeasurementPackage::LASER) {
    
    if (use_laser_) {
      NIS_laser_ = UKF::UpdateLidar(pack,
				    Xsig_pred_,
				    x_,
				    Sigma_,
				    std_laspx_,
				    std_laspy_,
				    beta,
				    kappa
				    );
    //std::cout <<"Laser NIS : "<<NIS_laser_<<endl;
      
    }
  }
  else if (pack.sensor_type_ == MeasurementPackage::RADAR) {// oh-oh...
    if (use_radar_) {
      VectorXd x_temp;
      MatrixXd Sigma_temp;
      NIS_radar_ = UKF::UpdateRadar(pack,
				    Xsig_pred_,
				    x_,
				    Sigma_,
				    std_radr_,
				    std_radphi_,
				    std_radrd_,
				    x_temp,
				    Sigma_temp,
				    beta,
				    kappa
				    );
      //std::cout <<"Radar NIS : "<<NIS_radar_<<endl;
      // for now just update the current state moments
      x_ = x_temp;
      Sigma_ = Sigma_temp;
    }
    
  }
}

double UKF::UpdateRadar(const MeasurementPackage& pack,
				 const MatrixXd& Xsig,  // The predicted/prior distribution as points along 
						        // the covariance matrix principal directions.
				 const VectorXd& x,     // The prior mean
				 const MatrixXd& Sigma, // The prior covariance
				 double std_radr,      // radar range stdev
				 double std_radphi,     // radar angle-to-object stdev
				 double std_radrd,     // radar range-rate stdev
				 VectorXd& x_post,      // The posterior mean
				 MatrixXd& Sigma_post,  // The posterior covariance
				                       // NOTE: We multiply the entries of Xsig with sqrt(1/(1 + kappa))
				 double beta,
				 double kappa,
				 double gamma      // A regularization parameter (employed by iterative updates) 
				) 
  {
    
    assert(pack.sensor_type_ == MeasurementPackage::RADAR);
    // skip update if degenrate measurement
    if (fabs(pack.raw_measurements_[0]) < 0.00001) {
     
      x_post = x;
      Sigma_post = Sigma;
      
      return 0; 
    }
    
    //set state dimension
    const int dim_x = 5;
    const int dim_joint = dim_x + 2; // this should be the dimension of the joint!!!!
    
    //Joint sigma points
    const int n_joint_sigma_points = 2 * dim_joint + 1;
    
    assert(Xsig.rows() == dim_x && Xsig.cols() ==  n_joint_sigma_points);
    assert(x.size() == dim_x);
    
    //measurement dimension
    const int dim_z = pack.raw_measurements_.size();

    // shortcut for the measurement vector
    VectorXd z = pack.raw_measurements_;
    
    //The lambda par5ameter (need to look into this rfeally...)
    double lambda = 3 - dim_joint;

    double alpha_sq = (lambda + dim_joint) / (dim_joint + kappa);
    
    // Create storage for the predicted measurement sigma-points
    MatrixXd Zsig = MatrixXd(dim_z, n_joint_sigma_points);

    //mean predicted measurement
    VectorXd z_pred = VectorXd::Zero(dim_z);
  
    //Run the sigma points through the measurement model 
    double w_m[n_joint_sigma_points]; // mean weights ...
    double w_c[n_joint_sigma_points]; // covariance weights ...
    
    for (int i = 0; i < n_joint_sigma_points; i++) {
      // get the weight out of the way first...
      if (i == 0) {
	
	w_m[i] = lambda / (lambda + dim_joint);
	w_c[i] = w_m[i] + (1 - alpha_sq) + beta;
      
      } else 
	w_m[i] = w_c[i] = 0.5 / (lambda + dim_joint);
      
      // Npw get the state in named variables
      double px = (1 / sqrt(1 + gamma) ) * Xsig(0, i),
             py = (1 / sqrt(1 + gamma) ) * Xsig(1, i),
             v = (1 / sqrt(1 + gamma) ) * Xsig(2, i),
             phi = (1 / sqrt(1 + gamma) ) * Xsig(3, i);
      double theta = (1 / sqrt(1 + gamma) ) * atan2(py, px);
      
      double vx = v * cos(phi),
             vy = v * sin(phi);
             
   // 2. Now storing ne
      double rho = sqrt(px * px + py * py);
      double rho_dot = rho > 0.0001 ? (vx * px + vy * py) / rho : 0;
      
      Zsig(0, i) = rho;
      Zsig(1, i) = theta;
      Zsig(2, i) = rho_dot;
      
      z_pred += w_m[i] * Zsig.col(i);
      //std::cout<<"Zsig currently : "<<std::endl<<Zsig<<std::endl;
  }

  
  // Now, S is the so-called "predicted measurement covariance".
  // NOTE: What S actually is, is the covariance matrix of the measurfement variable
  //       in the joint distrbution of the measurement likelihood and the prior. 
  MatrixXd S = MatrixXd::Zero(dim_z, dim_z);

  for (int i = 0; i < n_joint_sigma_points; i++) 
    S += w_c[i] * (Zsig.col(i) - z_pred) * (Zsig.col(i) - z_pred).transpose();  
  
  
  // And lastly, add the likelihood noise variances straight to the diagonal
  S(0, 0) += std_radr * std_radr;
  S(1, 1) += std_radphi * std_radphi;
  S(2, 2) += std_radrd * std_radrd;
   
  // Print the darn S...
  //std::cout<<"S : "<<std::endl<<S<<std::endl;
  
   // 2. Now storing new state mean and covariance
  // Cross-correlation matrix Sigma_xz
  MatrixXd Sigma_xz = MatrixXd::Zero(dim_x, dim_z);


  //calculate cross correlation matrix
  for (int i = 0; i < n_joint_sigma_points; i++) 
      Sigma_xz += w_c[i] * (Xsig.col(i) - x) *(Zsig.col(i) - z_pred).transpose(); 
  
  MatrixXd Sinv;
  if (S.determinant() == 0 )
    Sinv = (S + 0.0001*MatrixXd::Identity(dim_z, dim_z)).inverse();
  else 
    Sinv = S.inverse();
  
  
  //calculate Kalman gain K;
  MatrixXd K = Sigma_xz * Sinv;
  
  //update state mean and covariance matrix
  x_post = x + K * (z - z_pred);
  Sigma_post = Sigma - K*S*K.transpose();

  return (z - z_pred).dot( Sinv * (z - z_pred) );

  }
  
  // Do the Lidar update				
  double UKF::UpdateLidar(const MeasurementPackage& pack,
				 const MatrixXd& Xsig,  // The predicted/prior distribution as points along 
						        // the covariance matrix principal directions.
				 VectorXd& x,     // The state mean
				 MatrixXd& Sigma, // The state covariance
				 double std_laspx,      // Lidar px stdev
				 double std_laspy,     // Lidar py stdev
				 double beta,
				 double kappa
				 ) 
  {
    
    assert(pack.sensor_type_ == MeasurementPackage::LASER);
    
    // skip if bad measurement
    if (pack.raw_measurements_[0] * pack.raw_measurements_[0] + 
        pack.raw_measurements_[1] * pack.raw_measurements_[1] < 0.00001) return 0;
    
    //set state dimension
    const int dim_x = 5;
 
    
    const int dim_joint = dim_x + 2;
    
    
    //number of joint sigma points
    const int n_joint_sigma_points = 2 * dim_joint + 1;

    assert(x.size() == dim_x);
    assert(Xsig.rows() == dim_x && Xsig.cols() == n_joint_sigma_points);
    
    //measurement dimension
    const int dim_z = pack.raw_measurements_.size();

    // shortcut name for the measurement vector
    VectorXd z = pack.raw_measurements_;
    
    //define spreading parameter
    double lambda = 3 - dim_joint;
    
    // The α^2 parameter
    double alpha_sq = (lambda + dim_joint) / (dim_joint + kappa);
    
    // Create storage for the predicted measurement sigma-points
    MatrixXd Zsig = MatrixXd(dim_z, n_joint_sigma_points);

    //mean predicted measurement
    VectorXd z_pred = VectorXd::Zero(dim_z);
  
    //Now run the sigma points through the measurement model equations
    double w_m[n_joint_sigma_points]; // mean weights
    double w_c[n_joint_sigma_points]; // covariance weights
    
    for (int i = 0; i < n_joint_sigma_points; i++) {
      // compute the weight first thing...
      if (i == 0) {
	
	w_m[i] = lambda / (lambda + dim_joint);
	w_c[i] = w_m[i] + (1 - alpha_sq + beta);
      
      } else 
	w_m[i] = w_c[i] = 0.5 / (lambda + dim_joint);
      
      // Now obtaining the predicted values for position
      double px =  Xsig(0, i),
             py = Xsig(1, i);
             
      Zsig(0, i) = px;
      Zsig(1, i) = py;
      
      z_pred += w_m[i] * Zsig.col(i);
      //std::cout<<"Zsig currently : "<<std::endl<<Zsig<<std::endl;
  }

  // Now do the "predicted measurement" covariance, S (essentially the Z-block in the z, x joint)
  //NOTE: S is the covariance of the measurement variable (say, y to distinguish from the instantiation, z)
  //      in the joint distribution of the measurement likelihood with the prior.
  MatrixXd S = MatrixXd::Zero(dim_z, dim_z);
  for (int i = 0; i < n_joint_sigma_points; i++) 
    S += w_c[i] * (Zsig.col(i) - z_pred) * (Zsig.col(i) - z_pred).transpose();  
  
    
  // And lastly, add the likelihood noise variances straight to the diagonal
  S(0, 0) += std_laspx * std_laspx;
  S(1, 1) += std_laspy * std_laspy;
  
    
  // print the darn thing...
  std::cout<<"S : "<<std::endl<<S<<std::endl;
  
   // 2. Now obtaining new state mean and covariance
  // Cross-correlation matrix Sigma_xz 
  MatrixXd Sigma_xz = MatrixXd::Zero(dim_x, dim_z);
  //calculate cross correlation matrix
  for (int i = 0; i < n_joint_sigma_points; i++) 
      Sigma_xz += w_c[i] * (Xsig.col(i) - x) *(Zsig.col(i) - z_pred).transpose(); 
  
  //calculate Kalman gain K;
  MatrixXd Sinv;
  if (S.determinant() == 0 )
    Sinv = (S + 0.0001*MatrixXd::Identity(dim_z, dim_z)).inverse();
  else 
    Sinv = S.inverse();
  MatrixXd K = Sigma_xz * Sinv;
  //std::cout<<"K : "<<std::endl<<S<<std::endl;
  //std::cout<<"K*S*K' : "<<std::endl<<K*S*K.transpose()<<std::endl;
  //std::cout<<"Sigma : "<<std::endl<<Sigma<<std::endl;
  //update state mean and covariance matrix
  
  x = x + K * (z - z_pred);
  Sigma = Sigma - K*S*K.transpose();
  
  // return the NIS
  return (z - z_pred).dot( Sinv * (z - z_pred) );
  
  }
  
  // Generate the Sigma points given a prior and covariance matrix
  void UKF::GenerateSigmaPoints(const VectorXd& x,      // state mean
				         const MatrixXd& Sigma, // state covariance
				         MatrixXd& Xsig_out  // reference to sigma point matrix
 				    ) 
  {

	    //set state dimension
	    const int dim_x = x.size();
  
	    // number if sigma points
	    const int n_sigma_points = 2 * dim_x + 1;
  
	    //define spreading parameter
	    double lambda = 3 - dim_x;

	    //Cholesky decomposition of Sigma
	    MatrixXd L = Sigma.llt().matrixL();
	    /*Eigen::JacobiSVD<MatrixXd> svd(Sigma, Eigen::ComputeFullU | Eigen::ComputeFullV);
	    MatrixXd L = svd.matrixU();
	    VectorXd ss = svd.singularValues();
	    for (int i = 0; i<dim_x; i++) {
	      L.col(i) *= sqrt(ss[i]);
	      //std::cout<<"singular value : "<<ss[i]<<std::endl;
	      
	    }*/
	    
	    
	    if (Xsig_out.rows() != dim_x || Xsig_out.cols() != n_sigma_points) Xsig_out = MatrixXd(dim_x, n_sigma_points);
	    
	    
	    // fill-in the columns of Xsig
	    Xsig_out.col(0) = x;
	    for (int i = 1; i < dim_x; i++) {
    
	      Xsig_out.col(1 + i) = x + sqrt(lambda + dim_x) * L.col(i);
 
	      Xsig_out.col(1 + dim_x + i) = x - sqrt(lambda + dim_x) * L.col(i);
	    }
  
  }
  
  // Incorporate the "noisy" accelerations in a joint distribution described by new sigma points
  void UKF::GenerateJointSigmaPoints(const VectorXd& x,     // prior mean
					      const MatrixXd& Sigma, // prior covariance
					      double std_a,          // linear accelration standard deivation
					      double std_omega_dot,      // angular accelration standard deviation
					      MatrixXd& Xsig_joint  // The joint distribution sigma points
					      )  
  {
    
    const int dim_x = 5;
    const int dim_joint = dim_x + 2;
    const int n_joint_sigma_points = 2 * dim_joint + 1;
    double lambda = 3 - dim_joint;
    
    // 1. Create the joint covariance matrix
    MatrixXd Sigma_joint = MatrixXd::Zero(dim_joint, dim_joint);
    Sigma_joint.block<dim_x, dim_x>(0, 0) = Sigma;
    Sigma_joint(dim_x, dim_x) = std_a * std_a;  // linear acceleration along the vehicle axis ("longitudinal") variance
    Sigma_joint(dim_x + 1, dim_x + 1) = std_omega_dot * std_omega_dot; // angular acceleration variance
    // Joint covariance done...
    
    // 2. Decomposing the joint covariance matrix
    // NOTE: This is redundant, because the ellipsoid gains simply two more axes uncorrelated with the existing ones
    // and everything can be worked-out without the  additional Cholesky, but hey...
    MatrixXd L = Sigma_joint.llt().matrixL();
    // ************** SVD - L ********************
    /*Eigen::JacobiSVD<MatrixXd> svd(Sigma_joint, Eigen::ComputeFullU | Eigen::ComputeFullV);
    MatrixXd L = svd.matrixU();
    VectorXd ss = svd.singularValues();
    for (int i = 0; i<dim_x; i++) {
      L.col(i) *= sqrt(ss[i]);
      //std::cout<<"singular value : "<<ss[i]<<std::endl;
	      
    }*/
    // ************** SVD - L ********************
    if (Xsig_joint.rows() != dim_joint || Xsig_joint.cols() != n_joint_sigma_points) Xsig_joint = MatrixXd(dim_joint, n_joint_sigma_points);
    
    // 3. Now filling the sigma-point matrix of the joint distribution
    VectorXd x_joint(dim_joint);
    x_joint.segment<dim_x>(0) = x;
    x_joint[dim_x] = 0;
    x_joint[dim_x + 1] = 0;
    
    Xsig_joint.col(0) = x_joint;
    
    // And the rest of the columns now...
    for (int i = 0; i < dim_joint; i++) {
      
      Xsig_joint.col(1 + i) = x_joint + sqrt(lambda + dim_joint) * L.col(i);
      Xsig_joint.col(1 + dim_joint + i) = x_joint - sqrt(lambda + dim_joint) * L.col(i);
      
    }
    // Done ...
  }